<head>
  	<meta charset="utf-8">
  	<meta name="viewport" content="width=device-width">
	
	<title>
	
	  Interpolation in CSS without animation - Mike Riethmuller
	
	</title>

	<noscript>
		<link rel="stylesheet" href="https://madebymike.com.aucss/styles.min.css">
	</noscript>

	<meta name="twitter:card" content="summary" />
	<meta name="twitter:site" content="@MikeRiethmuller" />
	<meta name="twitter:title" content="Interpolation in CSS without animation - Mike Riethmuller" />
	<meta name="twitter:creator" content="@MikeRiethmuller" />
	<meta name="twitter:description" content="" />
	<meta name="twitter:image:src" content="https://madebymike.com.au/stuff/mug.jpg" />

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/manifest.json">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#FF6E4A">
	<meta name="theme-color" content="#FF6E4A">

	<link href='//fonts.googleapis.com/css?family=Handlee|Libre+Baskerville' rel='stylesheet' type='text/css'>
	<script>
		function loadCSS(e,t,n){"use strict";var i=window.document.createElement("link");var o=t||window.document.getElementsByTagName("script")[0];i.rel="stylesheet";i.href=e;i.media="only x";o.parentNode.insertBefore(i,o);setTimeout(function(){i.media=n||"all"})}
loadCSS( "/css/styles.min.css" );
	</script>

	

</head>
<body class="">
	<header>
		<div class="container">
			<ul>
				<li class="home"><a href="/">Home</a></li>
				<li class="writing"><a href="/writing">Writing</a></li>
				<li class="hire"><a href="/hire">Hire Me</a></li>
			</ul>
		</div>
	</header>
	

<article>
  <section>
    <div class="container">
      <h1 class="post-title">Interpolation in CSS without animation</h1>
      <span class="post-date"><time>December 29, 2016</time></span>

      

      <p>Interpolation is the estimation of a new value between two known values. This simple concept is vastly useful and it&rsquo;s commonly seen in animation on the web. With animation you declare the target properties and the end-state, and the browser will workout out the values in-between. Animation happens over time, but this is not the only dimension where interpolation can occur. In fact we interpolate values regularly in design, albeit manually, and particularly in responsive design. You may even do it unknowingly. Because of this, I think there is a need for a more native way of interpolating CSS values outside animation.</p>

<p>
If you are a web designer the chances are you frequently have two primary screen sizes in mind, a small screen and a large screen, or the device and the desktop. I know you probably think about more than just these two sizes, but these two sizes are especially important, they represent the upper and lower bounds of your design. When you make adjustments for screen sizes between these constraints, what you are doing is like interpolation.</p>

<p>When adjusting properties such as font-size, font-weight, image width or grid dimensions at specific screen sizes between the upper and lower bounds, these values usually fall somewhere between the choices you&rsquo;ve made for the largest small and smallest screen size. It would be unusual for the font to get larger, then smaller, then larger again as the viewport changes. Or to give another example, if a font varied between bold, normal, italic, then bold and italic. It&rsquo;s not unusual for these things to change from one state to another, but typically these changes are progressive, not back and forward.</p>

<h2 id="design-intent-vs-constraints">Design intent vs constraints</h2>

<p>We choose break-points where properties are to be adjusted. We don&rsquo;t do this because it is ideal, we&rsquo;re forced to select a fixed number break-points, often quite arbitrarily, where the design should change. Although sometimes we may want these break-points, more often it is due to technical limitations on the web.</p>

<p>Media queries are our primary tool for adjusting design in relation to the screen size and for practical reasons, we are constrained to using a limited number of these. These limitations have shaped how we think about web design, and the choices we make about using break-points don&rsquo;t necessarily reflect the pure intentions of the designer.</p>

<p>I&rsquo;ve been told that good design is rarely arbitrary. It serves a purpose. If the font size is smaller, larger or its weight stronger, it&rsquo;s because that is the best experience for users, at that screen size. It&rsquo;s feasible to say that the best experience for some aspects of design, will vary directly in relation to the screen size rather than only at set points. This is the use-case for interpolation without animation.</p>

<p>Let&rsquo;s illustrate this with an example, imagine the following CSS:</p>

<pre><code>body {
  font-weight: bold;
}

@media screen and (min-width: 700px){
  body {
    font-size: 1.2rem;
    font-weight: normal;
  }
}
</code></pre>

<p>It&rsquo;s unlikely a designer would decide bold font is uniquely suited to screen resolutions below 700px. Why would one pixel make such a difference? Design decisions like this are often the result of constrains imposed by media queries. A more likely intention is for the font-weight to be adjusted in relation to its size, for improved legibility on smaller screens.</p>

<p>Media queries are the best tool available for approximately achieving this goal, but they are not always an accurate reflection of the designers intent.</p>

<h2 id="maximum-safe-operating-pressure">Maximum safe operating pressure</h2>

<p>I noticed the label on my barbecue gas cylinder says it has a maximum safe operating pressure. If I exceed this pressure when refilling it, it might explode (it actually won&rsquo;t, they have safety valves, but just imagine would). Web design doesn&rsquo;t explode quite as spectacularly as gas cylinders, but responsive design is exposed to a different kind of operating pressure.</p>

<p>As the screen size gets smaller, there is often a point where a design is pressured by the limitations imposed by smaller screens. A break-point represents the point where the design cannot withstand this pressure any longer; it reached its maximum safe operating pressure and the appropriate response is to adjust some aspects of the design.</p>

<p>Designers choose these break-points carefully. They probably have in mind where constraints like this begin to pressure the design, and how quickly it impacts overall quality. But in a compromise to technology, we are forced to choose a middle point, knowing that immediately before and after the break-point the design is often still pressured by constrains that demanded change.</p>

<p><img src="/img/interpolation.png" alt="gradient demonstrating the location of ideal font-sizes in relation to a break-point and the design pressure experienced between these points" /></p>

<p>This graphic attempts to illustrate the location of ideal font-sizes in relation to a break-point. You can move the ideal font-size closer to the break-point but this only shifts the pressure to somewhere else in the design. Alternatively you can add more break-points until this becomes problematic, but ideally these changes would be introduced gradually and continuously to reduce pressure on the design as it&rsquo;s required.</p>

<p>Media queries are not the right tool for this. Media queries have been around longer than responsive design and responsive design was as much a reaction to the available technology, as the idea of media queries was to user needs. As is often the case, real world implementations of responsive design pushed the technology further than spec writers had imagined, and uncovered new uses, new requirements and new limitations.</p>

<p>This is normal process. And with the perspective we have now, it&rsquo;s easy to ask, if we were designing a technical solution for responsive design today, would media queries be the best tool to implement designers intentions? I think not; or at least not the only tool.</p>

<h2 id="live-interpolation-in-the-browser-today">Live interpolation in the browser today</h2>

<p>Theoretically, between two ideal points, there is an ideal value for every screen size, that can be expressed as a ratio, or a function relative to the screen-size (or even another relative factor).</p>

<p>Previously I&rsquo;ve written about techniques you can use to achieve some forms of interpolation using calc() and viewport units.</p>

<p>My favourite example of this demonstrates how you can interpolate between different modular scales with heading levels.</p>

<video src="/img/modular-scale.mp4" style="max-width:600px" autoplay loop></video>

<p>Not only do the individual font-sizes change in a controlled way relative to the viewport, but the ratio between the heading levels also fluidly changes. This means there is a changing but consistent relationship between each of the headings. If you haven&rsquo;t seen this yet, you should read my article <a href="https://madebymike.com.au/writing/precise-control-responsive-typography/">precise control over responsive typography</a>.</p>

<p>This technique allows linear interpolation between any two length values. This is great, but linear interpolation is not the only form of interpolation, and length values are not the only properties that change in responsive design. In addition to that, the first example in this article demonstrated a situation where font-size should change relative to the screen size, and font weight should change relative to font-size. At the moment this isn&rsquo;t possible with CSS.</p>

<h2 id="limitations-of-interpolation-with-calc">Limitations of interpolation with calc()</h2>

<p>There are some limiting factors when it come to changing the font-weight in relation to the font-size. Firstly the calc() techniques work only with length values and font-weight is a unitless value.</p>

<p>The problem with interpolating unitless values could potentially be solved with something called &lsquo;unit algebra&rsquo;. Unit algebra would allow calc() expressions that contain CSS units to resolve to a different unit type or even a unitless number. E.g <code>calc(2rem * 2rem) = 4</code>. This could allow us to interpolate unitless values like font-weight or line-height, and maybe even open the door to non-linier equations (by multiplying units by themselves). Whilst this would be a great feature, the syntax for these equations is likely to be complicated and still leaves us wanting a more native solution. We&rsquo;re also not likely to see this anytime soon. As far as I am aware there is no formal proposal, and this exists only as an idea discussed in w3c mailing lists.</p>

<p>The second problem with interpolating properties like font-weight is that by default a web font won&rsquo;t have all the variations required to smoothly interpolate between these values. Usually a font-family will include the standard font and a single variation for bold, or at worse, just a faux-bold. Adding more variations will increase network requests, loading time and FOUF (Flash Of Unstyled Font). This is another constraint designers will be familiar with.</p>

<h2 id="variable-fonts-and-the-future-of-font-interpolation">Variable fonts and the future of font interpolation</h2>

<p>Luckily the problem of limited font variations has a solution that is relatively close on the horizon. Variable fonts offer the ability to specify how bold or italic a font should be. And not just bold or italic but other &lsquo;axes of variation&rsquo;. You can read more about variable fonts in Andrew Johnson&rsquo;s excellent A List Apart article: <a href="http://alistapart.com/article/live-font-interpolation-on-the-web">Live font interpolation on the web</a>.</p>

<p>In his article Andrew mentions a need for
&ldquo;bending points—not just breaking points—to adapt type to the design&rdquo;. He also hints at <a href="http://alistapart.com/article/live-font-interpolation-on-the-web#section8">some challenges we face interpolating font-values effectively</a> on the web.</p>

<p>My main concern is that many of these &lsquo;axes of variation&rsquo; are not length values and therefor, whilst I&rsquo;m excited for the opportunities that variable font will provide, I see their potential limited by existing constraints.</p>

<h2 id="how-interpolation-and-animation-works-in-browsers">How interpolation and animation works in browsers</h2>

<p>CSS is already great at interpolating values and it knows how to do this with a whole bunch of different <a href="https://www.w3.org/TR/css3-transitions/#animatable-properties">animatable properties</a> and <a href="https://www.w3.org/TR/css3-transitions/#animatable-types">property types</a>.</p>

<p>We can interpolate the value of any property that <a href="http://canianimate.com/">can be animated</a> using CSS transitions or keyframe animations.</p>

<p>During an animation the browser works out how much time has elapsed for every frame and picks an intermediary value. For example if 1 second of a 4 second animation has elapsed, we pick a point that is 25% of the way between the original and final value.</p>

<p><object data="/img/easing.svg" type="image/svg+xml"></object></p>

<p>This is easy to understand with numeric properties like width or position, but it works exactly the same with properties like color. Just imagine the same process happening for each of the R, G and B values that represents the color. You can think of them as 3 separate 2D interpolations that combine to give a color at each step of the animation.</p>

<blockquote>
<p>An interesting side note with CSS animations, is that no matter what values you use to define color the browser will always transition through an RGB colour space. This means that although the final colour will be the same, the path taken and intermediary colors will be different.</p>
</blockquote>

<p>We can manipulate the timing of an animation to get different results at different points of interpolation. By plotting an animation timing function on the same graph above, we can see how this changes the value returned at different points in the animation, while the start and end values remain the same.</p>

<p><object data="/img/easing2.svg" type="image/svg+xml"></object></p>

<p>This is a non-linear interpolation and it’s really handy for creating all kinds of animation effects and more natural looking movement with acceleration and easing. We can define <a href="https://developer.mozilla.org/en/docs/Web/CSS/animation-timing-function">animation timing functions in CSS</a> using <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function">keywords, steps or cubic bezier curves</a> for greater control.</p>

<h2 id="interpolation-outside-animation">Interpolation outside animation</h2>

<p>So far I&rsquo;ve discussed the problem with media queries not always reflecting design intentions, and the limitations of interpolation with calc(). I&rsquo;ve also shown how new features like variable fonts might be constrained by these limitations. The interesting thing is, we have all the tools we need to solve these problems, in CSS right now. Only they are tied closely to animation in the browser.</p>

<p>The rest of this article is going to talk about the idea of exposing a native interpolation function in CSS, how it might work, and what problems might solve. It&rsquo;s very hypothetical and it&rsquo;s ok if you don&rsquo;t agree with either the idea in general or how it should work.</p>

<p>I&rsquo;ve talked about interpolation and animation together, however interpolating values over time is just one possibility. The duration and elapsed time of an animation simply provides a percentage completion. Somewhere within the browser an interpolation function is called and it will dutifully return a value at the given percentage completion, according to the timing function.</p>

<p>Let’s imagine we could access this function directly in CSS and pass it our own percentage. If we could change this value using media queries, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS variables (custom properties)</a> and calc(), what are some of the things we might be able to do?</p>

<p>First let’s imaging a syntax. We need an <code>initial-value</code>, a <code>target-value</code>, a <code>percentage-completion</code> and a <code>timing-function</code>. The timing function could be an optional value and default to a linear interpolation. That means it might look something like this:</p>

<pre><code>interpolate(initial-value, target-value, percentage-completion, [timing-function])
</code></pre>

<p>And could be used like this:</p>

<pre><code>.thing {
  width: interpolate(0px, 500px, 0.5, linear);
}
</code></pre>

<p><strong>Note</strong>: This is a not real CSS, it is a hypothetical solution to a real problem for the purpose of discussion.</p>

<p>Obviously in the example above it would be far easier to set the width to 250px. So, interpolation functions are not that useful without variables. We do have some variable values in CSS. Things like:</p>

<ul>
<li>the viewport width and height,</li>
<li>the width and height of an element or its container,</li>
<li>the number of siblings an element has, or</li>
<li>the order of an element amongst its siblings.</li>
</ul>

<p>These are all things that in one context or another we can know and use in CSS; unfortunately in many cases these variables are not easily queried to create conditional statements. There are some useful tricks to take advantage of them. Things like <a href="https://madebymike.com.au/writing/precise-control-responsive-typography/">advanced fluid typography</a> and <a href="http://alistapart.com/article/quantity-queries-for-css">quantity queries</a> are great real world examples.</p>

<p>A more hypothetical example in a native interpolation function might look something like this:</p>

<pre><code>--max-viewport: 500px;
--min-viewport: 1000px;
--range: var(--max-viewport) - var(--min-viewport);
--percentage-completion: calc( (100vw - var(--min-viewport)) / var(--range) );

.thing {
  width: interpolate(0px, 500px, var(--percentage-completion), ease-in);
}
</code></pre>

<p>Although the above calculation is quite simple, but it&rsquo;s more than a bit ugly. This is because it uses CSS variables and unit algebra concepts I mentioned earlier to work out a percentage completion.</p>

<p>A far neater solution would be a function to work out a percentage. This would reduce the above to something far more digestible like this:</p>

<pre><code>--percentage-completion: percentage(500px, 1000px, 100vw);

.thing {
  width: interpolate(0px, 500px, var(--percentage-completion), ease-in);
}
</code></pre>

<p><strong>Note:</strong> Any interpolation function would probably need to clamp returned values to the specified range, as negative completion percentage are a likely result with variables.</p>

<p>This doesn&rsquo;t need to work with just length values. I mentioned that CSS has a whole bunch of <a href="https://www.w3.org/TR/css3-transitions/#animatable-properties">animatable properties</a> that it already knows how to interpolate. It makes sense that any native function should work with these definitions. This means interpolating a color is also valid:</p>

<pre><code>--percentage-completion: percentage(500px, 1000px, 100vw);

.thing {
  background-color: interpolate(red, greed, var(--percentage-completion));
}
</code></pre>

<p>The above example of changing the background color doesn&rsquo;t make much sense in relation to the viewport, but there are more legitimate use cases for interpolating a color in relation to an elements width. We just can&rsquo;t as easily query the properties needed to do this, as we can with the viewport. <a href="http://alistapart.com/article/container-queries-once-more-unto-the-breach">Container queries</a> seem to be forever on the horizon. It won&rsquo;t be soon, but my hope is that container queries also ship with container and element units, that work much like viewport units, only for the width of an element.</p>

<p>Container query units might look something like this:</p>

<table>
<thead>
<tr>
<th>Unit</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>cqw</td>
<td>Relative to 1% of the container width</td>
</tr>

<tr>
<td>cqh</td>
<td>Relative to 1% of the container height</td>
</tr>

<tr>
<td>cqmin</td>
<td>Relative to 1% of the container width or height, whichever is smaller</td>
</tr>

<tr>
<td>cqmax</td>
<td>Relative to 1% of the container width or height, whichever is larger</td>
</tr>

<tr>
<td>eqw</td>
<td>Relative to 1% of the element width</td>
</tr>

<tr>
<td>eqh</td>
<td>Relative to 1% of the element height</td>
</tr>

<tr>
<td>eqmin</td>
<td>Relative to 1% of the element width or height, whichever is smaller</td>
</tr>

<tr>
<td>eqmax</td>
<td>Relative to 1% of the element width or height, whichever is larger</td>
</tr>
</tbody>
</table>

<p><strong>Note</strong>: I used the <code>cq</code> prefix is because <code>ch</code> is already a valid unit type and <code>eq</code> for consistency.</p>

<p>With units like these, we could do something like this:</p>

<pre><code>--percentage-completion: percentage(0px, 100cqw, 100eqw);

.thing {
  background-color: interpolate(red, greed, var(--percentage-completion));
}
</code></pre>

<p>In this example the percentage-completion is the percentage width of a child element, in relation to it&rsquo;s parent element. Allowing CSS property values to be relative to context like this opens up a whole range of possibilities for things like, dynamic progress bars, creative navigation components and data-visualisation.</p>

<p>But maybe this isn&rsquo;t the right solution. If we have a unit type for viewport width, container width and element width, where does this stop? DOM order, line length, color? Is it better introduce another function to get a value? E.g. <code>value-of(width)</code> if we do this, what about container width and non CSS properties like DOM order or line length? Magic keywords? <code>value-of(dom-order)</code>. I don&rsquo;t know!</p>

<p>Perhaps you don&rsquo;t agree with any of this. Perhaps you think we shouldn&rsquo;t introduce more functional features to CSS. That&rsquo;s ok. I hope you will agree that there is a need for discussion, that break-points don&rsquo;t necessarily match the intentions of designers and that interpolation will become a more significant feature of web design with the introduction of variable fonts, and an increasing adoption of viewport units and dynamic layout features.</p>

<p>I&rsquo;d like to start a discussion and if you have ideas please <a href="https://twitter.com/MikeRiethmuller">let me know</a> or consider <a href="https://github.com/w3c/csswg-drafts/issues/581">contributing to the issue</a> on the CSS Working Group&rsquo;s, GitHub page.</p> 

    </div>
  </section>
</article>





    <footer>
      <section>
        <div class="container">
          <ul>
            <li><a href="http://codepen.io/MadeByMike/"><svg class="logo"><use xlink:href="#codepen-logo"></use></svg>Me</a></li>
            <li><a href="https://twitter.com/MikeRiethmuller"><svg class="logo"><use xlink:href="#twitter-logo"></use></svg>Me</a></li>
            <li><a href="https://github.com/MadeByMike"><svg class="logo"><use xlink:href="#github-logo"></use></svg>Me</a></li>
          </ul>
        </div>
      </section>
    </footer>

      <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
	<symbol id="codepen-logo" viewBox="0 0 512 512">
		<path d="M427 201.9c-0.6-4.2-2.9-8-6.4-10.3L264.2 87.3c-4.9-3.3-11.4-3.3-16.3 0L91.4 191.6c-4 2.7-6.5 7.4-6.5 12.2v104.3c0 4.8 2.5 9.6 6.5 12.2l156.4 104.3c4.9 3.3 11.4 3.3 16.3 0L420.6 320.4c4-2.6 6.6-7.4 6.6-12.2V203.9C427.1 203.2 427.1 202.6 427 201.9 427 201.7 427.1 202.6 427 201.9zM270.7 127.1l115.2 76.8 -51.5 34.4 -63.8-42.7V127.1zM241.3 127.1v68.6l-63.8 42.7 -51.5-34.4L241.3 127.1zM114.3 231.4l36.8 24.6 -36.8 24.6V231.4zM241.3 384.9L126.1 308.1l51.5-34.4 63.8 42.6V384.9zM256 290.8l-52-34.8 52-34.8 52 34.8L256 290.8zM270.7 384.9V316.3l63.8-42.6 51.5 34.4L270.7 384.9zM397.7 280.6l-36.8-24.6 36.8-24.6V280.6z"/>
	</symbol>
	<symbol id="github-logo" viewBox="0 0 512 512">
		<path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/>
	</symbol>
	<symbol id="twitter-logo" viewBox="0 0 512 512">
		<path d="M419.6 168.6c-11.7 5.2-24.2 8.7-37.4 10.2 13.4-8.1 23.8-20.8 28.6-36 -12.6 7.5-26.5 12.9-41.3 15.8 -11.9-12.6-28.8-20.6-47.5-20.6 -42 0-72.9 39.2-63.4 79.9 -54.1-2.7-102.1-28.6-134.2-68 -17 29.2-8.8 67.5 20.1 86.9 -10.7-0.3-20.7-3.3-29.5-8.1 -0.7 30.2 20.9 58.4 52.2 64.6 -9.2 2.5-19.2 3.1-29.4 1.1 8.3 25.9 32.3 44.7 60.8 45.2 -27.4 21.4-61.8 31-96.4 27 28.8 18.5 63 29.2 99.8 29.2 120.8 0 189.1-102.1 185-193.6C399.9 193.1 410.9 181.7 419.6 168.6z"/>
	</symbol>
	<symbol id="arrow-icon" viewBox="0 0 10 10">
		<polygon points="1,0 9,5 1,10 "/>
	</symbol>
	<symbol id="arrow-icon-reverse" viewBox="0 0 10 10">
		<polygon points="9,0 1,5 9,10"/>
	</symbol>
  </svg>

    <script type="text/javascript">
if ( 'serviceWorker' in navigator && (typeof Cache !== 'undefined' && Cache.prototype.addAll) ) {
  navigator.serviceWorker.register('/sw.js');
}
</script>




  </body>
</html>